在linux系统中，对于每一次读取IO请求操作，数据并不会直接拷贝到用户程序的用户空间缓冲区，它首先会拷贝到操作系统的内核空间，然后才会从操作系统内核缓冲区拷贝到用户空间的缓冲区。

IO主要分为以下三种

* 内存IO
* 网络IO
* 磁盘IO

#### 同步阻塞IO模型

最简单的一种IO模型，简单理解就是死等，即进程或线程一直等待某个条件，不满足就会一直等待。当用户程序执行read，线程会被阻塞，一直等到内核数准备好，并把数据从内核缓冲区拷贝到应用程序的缓冲区，当拷贝过程完成，read才会返回。

* 适用场景：并发量小的网络应用开发，JavaBIO
* 优点：易于开发，不消耗CPU资源，响应及时
* 缺点：不适用于并发量较大的网络应用开发，一个请求一个线程，系统开销较大。

#### 同步非阻塞IO模型

应用进程与内核交互，不断轮询，不停地去询问内数据是否准备好。如果没有准备好就返回error。应用进程得到error后，过一段时再发送请求，在这两次请求时间内，进程可以先做其它的事件。如果准备好了，将数据拷贝到用户空间。

* 适用场景：并发量较小，且不用技术响应的网络应用发发。
* 优点：易于开发，可以在轮询的间断期间继续执行程序。
* 缺点：不适用于与并发量较大的网络应用开发，一个请求一个线程，系统开销大，消耗CPU资源，响应不及时。

#### 多路复用IO模型

IO多路复用实际就是select、poll、epoll监听多个IO对象，当IO对象有变化时，就通知用户进程，好处就是单个进程可以处理多个socket。

* 适用场景：并发量大且对响应要求有较高的网络应用开发，JavaNIO
* 优点：将阻塞从多个进程转移到一个select调用身上，假如并发量大的select调用是不易被阻塞的。
* 缺点：实现难度较大，当并发量较小时优势不明显。

#### 信号驱动IO模型

进程预先注册一个信号处理函数，当内核数据准备好之后发送一个信号给进程。

* 优点：将阻塞从多个进程转移到了一个select调用身上，假如并发量大的话select调用是不易被阻塞的，或者说阻塞时间短的。
* 缺点：不易开发，实现难度大。



以上四个IO模型都可以看出来，到最后用户进程都要在数据从内核buffer复制到用户buffer时阻塞，直到内核告诉进程准备成功。这就是同步进程，就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作。

#### 异步IO模型

用户进程发起read操作，告诉内核当整个操作完成时，如何通知我们，立刻就可以开始去做其它的事，内核收到read操作后会立刻返回，所以不会对用户进程产生阻塞，然后内核会等数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，内核会给用户进程发送一个信号，告诉read操作完成。



* 应用场景：Java AIO，适合高性能高并发应用。
* 优点：不阻塞，减少了线程切换，
* 缺点：难以实现，要操作系统支持。





#### Linux-epoll

在linux系统中epoll池，在高并发、高吞吐的IO系统中经常会使用到epoll。

