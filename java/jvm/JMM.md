CPU运算速度远大于物理内存，CPU运行时并不是直接操作内存的，而是先把内存里的数据读到缓存，因此内存的读写操作就会造成不一样的问题。java内存模型(java memory model)来屏蔽掉各种硬件和操作系统的内存访问差异，以实现java程序在各种平台下都能达到一致的内存访问效果。JMM本身是一种抽象的概念，并不是真实存在的。它描述是的一组约定或规范，通过这组规范定义了程序中（尤其是多线程）各个变量的读写访问方式并决定一个线程对共享变量的写入何时以及如何变成对另一个线程可见，关键技术点都是围绕多线程的原子性、可见性和有序性展开的。
* 通过JMM来实现线程和主内存之间的抽象关系。
* 屏蔽各个硬件平台和操作系统的内存访问差异以实现让Java程序在各种平台下都能达到一致的内存访问效果。

JMM是属于是JVM的一部份，只是JMM是一种抽象的概念是一组规则，并不实际存在，JMM模型定义的内存分为工作内存和主内存，工作内存是从主内存拷贝副本，属于线程私有。

#### 可见性
可见性，是指当前一个线程修改了某个共享变量的值，其它线程是否能立即知道该变更，JMM规定了所有的变量都在储在主内存中。java中普通的共享变量不保证可见性，因为数据修改被定入内存的时机是不确定的，多线程并发下很有可能出现脏读，所以每个线程都有自已的本地工作内存。线程自已的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的读写都必须在线程本地工作区中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存的变量，线程间变量值的传递需要通过主内存完成。

#### 原子性
原子性，指一个操作是不可中断的，即使是多个线程一起执行时候，一个操作一旦开始，就不会被其它线程干扰。


#### 有序性
有序性是代码的执行，会根据编译器和处理器通常会对指令序列进行重新排序。指令重排可以保证串行语义一致，但没有义务保证多线程的语义也是一致的。即可能产生脏读。处理器在进行重排序时必须要考虑指令之间的数据依赖性。多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的。
源代码->编译器优化重排->指令并行重排->内存系统重排->最终执行指令


#### happens-before
在JMM中，如果一个操作执行的结果需要对另一个操作可见，或者代码重排序，那么这两个操作之间必须存在happens-before关系，即前一个操作的结果可以被后续操作获取。

1. 次序规则：一个线程内，按照代码顺序，写在前面的操作先行发生于写在后面的操作。

2、锁定规则

一个unLock操作先行发生于后面（这里的“后面”是指时间上的先后）对同一个锁的lock操作。

3、volatile变量规则

对一个volatile变量的写操作先行发生于后面对这个变量的读操作，前面的写对后面的读是可见的，这理的“后面"同样是指时间上的先后。

4、传递规则

如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C。

5、线程启动规则（Thread Start Rule）

Thread对象的start()方法先行发生于此线程的每一个动作。

6、线程中断规则（Thread Interruption Rule）

对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。可以通过Thread.interrupted()检测到是否发生中断。

7、线程终止规则（Thread Termination Rule）

线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止热行。

8、对象终结规则（Finalizer Rule）

一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。

即对象没有完成初始化之前，是不能调用finalized()方法的。