https://www.cnblogs.com/koik/p/4452029.html


### JVM内存空间包括：方法区、java堆、java栈、本地方法栈
* 方法区：是整个线程共享区域，存放类信息、常量、静态变量
* java堆：线程共享区域，类的实例就放在这个区域，如果一个系统会产生很多实例，因此java堆空间也就是最大，如果java堆空间不足，程序会抛出OutOfMemoryError
* java栈：每个线程私有的区域，它的生命周期和线程相同，一个线程对应一个java栈，每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”，而栈帧中包括了方法中的局部变量、用于存放中间状态值的操作栈。如果java栈空间不足会抛出StackOverflowError。递归如果深度较深，就会执行大量的方法，方法越多java栈的占用空间就越大。
* 本地方法栈：和java栈类似，只不过它是用来表示执行本地方法的，本地方法栈存放的方法调用本地方法接口，最终调用本地方法库，实现与操作系统硬件交互的目的。
* PC寄存器：实例对象、方法、静态变量都去了自已该去的地方，程序该怎么执行，哪个方法先执行，哪个方法后执行，这些指令的顺序就是PC寄存器管理，它的作用就是控制程序指令的执行顺序。

jvm 堆栈
java  -Xms -Xmx -XX:PermSize -XX:MaxPermSize
jvm按照其存储数据的内容将所需内存分配为堆区和非堆区
* 堆区：即通过new方式创建的对象（类实例）所占用的内存空间。
* 非堆区：即为代码、常量、外部访问（如文件访问流所占资源）等

### 堆区参数
* Xms：表示java虚拟机堆区内存初始内存分配的大小
* Xmx：表示java虚拟机堆区内存可被分配的最大上限
* XX:newSize：表示新生代初始内存的大小，应该小于 -Xms的值；
* XX:MaxnewSize：表示新生代可被分配的内存的最大上限；当然这个值应该小于 -Xmx的值；
* Xmn：这个参数则是对 -XX:newSize、-XX:MaxnewSize两个参数的同时配置
> 通常Xms、Xmx两个参数配置成相同的值，目的是为了能够在java垃圾回收机制清理完成堆区后不需要重新分隔计算堆区的大小而浪费资源。
> java中每新new一个对象所占用的内存空间就是新生代的空间，当java垃圾回收机制对堆区进行资源回收后，那些新生代中没有被回收的资源将被转移到中生代，中生代的被转移到老生代。
### 非堆区参数
* XX:PermSize：表示非堆区初始内存分配大小，permanent size持久化内存
* XX:MaxPermSize：表示非堆区分配的内存最大上限


##### jvm内存泄漏原因分析
jvm由5大块组成：堆、栈、本地方法栈、程序计数器、方法区，栈主要记录方法的执行和对象的引用，堆则存在真正的引用对象。
内存泄漏是由于使用不当，把一部份内存丢掉了，导致这部份内存不可用。
当在堆中创了对象，后来没有使用这个对象了，又没有把整个对象的相关引用设为null，些垃圾收集器会认为这个对象是需要的，就不会清理这部份内存，这会致这块内存不可用。所以内存泄漏会导致可用内存减少，进而导致内存溢出。
##### jvm垃圾回收机制思想
从栈root出发，遍历对象的引用，在遍历堆里面的引用对象，因为栈中的对象引用执行完毕就删除，所以我们可以通过栈中的对象引用，查找堆中没有被指向的对象，这些对象即为不可达对象，进行回收。

#### 常见的四种内存溢出情况
* 堆溢出(OutOfMemoryError:java heap space)
* 持久代溢出(OutOfMemoryError: PermGen space)
* 栈溢出(StackOverflowError)
* OutOfMemoryError:unable to create native thread