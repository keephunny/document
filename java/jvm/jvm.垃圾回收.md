https://www.cnblogs.com/shiblog/p/15956179.html
#### 垃圾回收算法
##### 标记阶段算法
在堆里存放着几乎所有的java对象实例，在GC执行回收前，首先需要区分内存中哪些是存活对象，哪些是死亡对象，只有被标记为已死亡的对象，GC才会在执行垃圾回时，释放掉其所占用的内存空间，因些这个过程称为垃圾标记阶段。
* 引用计数算法
    引用计数法(refrence counting)比较简单，对每个对象保存一个整型的引用计数器属性，用于记录对象被引用的情况。
    优点：实现简单，垃圾对象便于辨识，判定效率高，回收没有延时性。
    缺点：它需要单独的字段存储计数器，这样的做法增加了存储空间的开销，每次赋值都需要更新计数器。无法处理循环引用的问题，导致java垃圾回收器中没有使用这类算法。
* 可达性分析算法
    相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地解决在引用计数算法中循环引用的问题，防止内存泄漏的发生。
    将对象和引用关系看作一个图，选定活动的对象作为GC Roots，然后跟踪引用链条，如果一个对象和Root之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。
    * 可达性分析算法是以根对象集合为起如点，按照从上至下的方式搜索根对象集合所连接的目标对象是否可达。
    * 使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为引用链(Reference Chain)
    * 实现简单，执行高效 ，有效的解决循环引用的问题，防止内存泄漏。
###### GC Roots
GC Roots主要包括以下几类元素
* 虚拟机栈中引用的对象，各线程被调用的方法中使用到的参数、局部变量等。
* 方法区中类静态属性引用的对象
* 方法区中常量池中的引用
* 所有被同步锁synchronized持有的对象 
* jvn内部的引用，基本数据类型对应的class对象，一些常驻的异常对象
* 本地方法栈内JNI引用的对象
* 由于Root 采用栈方式存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个Root 。
##### 清除阶段算法
###### 标记清除算法
    对存活的对象进行标记，清除掉没有标记的对象。效率比较低，递归与全堆对象遍历两次，进行GC的时候，需要停止整个应用程序，导致用户体验差，这个方式清理出来的空间不连续，产生内存碎片。
###### 复制算法
    将活着的内存空间分为两块，每次只使用其中一块，在GC时将正在使用的内存中存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存角色，最后完成垃圾回收。
    复制过去以后保证空间的连续性，不会出现“碎片”问题。此算法的缺点也是很明显的，就是需要两倍的内存空间。
    在新生代，对常规应用的垃圾回收，一次通常可以回收70%-99%的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。
###### 标记压缩算法
    复制算法的高效性是建立在存活对象，垃圾对象多的前提下，这种情况下在新生代经常发，但是在老年代，更常见的情况是大部份对象都是存活的。如果依然使用复制算法，由于存活对象较多，复制成本将很高。标记清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以JVM 的设计者需要在此基础之上进行改进。标记 - 压缩（Mark - Compact）算法由此诞生。
指针碰撞： 
    如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bulp the Pointer)。
优点：
* 消除了标记/清除算法中内存区域分散的缺点，jvm只需要持有一个内存起始地址即可。
* 消除了复制算法中，内存需要两倍的问题。
缺点：
* 从效率上说，标记压缩算法要低于复制算法，不仅要标记所有存活对象，还要整理所有存活对象的引用地址。
*  移动对象的同时，如果对象被其它对象引用，则还需要调整引用的地址。
* 移动过程中STW。

###### 分代收集算法
目前几乎所有的GC都是采用分代收(Generational Collecting)算法执行垃圾回收。
年轻代：
* 区域相对老年较小，对象生命周期短，存活率，回收频繁。
* 这种情况复制算法的回收整理速度最快，复制算法的效率只和当前存活对象的大小有关，因此很适用于年轻代的回收。面复制算法利用率不高的问题，通过hotspot中的两个survivor的设计得到缓解。
老年代：
* 区域较大，对象生命周期较长，存活率高，回收不频繁。
* 复制算法不合适，一般由标记清除或标记压缩的混合实现。

###### 增量收集算法
###### 分区算法
#### 内存泄漏
对象不会被再程序使用，但是GC又不能回收的情况，称为内存泄漏
1. 静态集合类
    静态集合类，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与JVM程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。
2. 单例模式
    单例模式和静态集合的原因类似，因为单例的特性，它的生命周期和JVM的生命周期是一样的，所以如果单例对象持有外部对象的引用，那个这个对象也不会被回收，那么就容易造成内存泄漏。
3. 内部类持有外部类
    如果一个外部类的实例对象的方法返回一个内部类的实例对象，这个内部类对象被长期引用，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部对象将不会被垃圾回收，造成内存泄漏。
4. 各种连接、数据库、网络、IO等
    与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。
5. 变量不合理的作用域
    一个变量定义的范围大于其使用范围，很有可能造成内存泄漏，另一方面如果没有及时的把对象设置null，也有可能造成内存泄漏。
6. 改变哈希值
    当一个对象被存储进hashset集合中，就不要修改这个对象中参与计算哈希值的字段了。否则对象修改后的哈希值与最初存储在hashset集合中的哈希值就不同了。在这种情况下，即使contains方法使用该对象的当前引用作为参数去hashset集合中检索对象，也将返回null，这会导致无法从hashset集合中单独删除当前对象，造成内存泄漏。
7. 缓存泄漏
    内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，就很容易遗忘处理。可以使用WeakHashMap代表缓存（弱引用），此种Map的特点是，当除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值。
8. 监听器和回调
    如果客户端在你实现的API中注册回调，却没有显式的取消，那么就会积聚。需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为WeakHashMap中的键。 


