### 粘包和拆包的原因

​		TCP是个流协议，流是一个没有界限的一串数据。TCP底层并不了解上层业务数据的含义，它会根据TCP缓冲区的实际情况进行包的划分，所以一个完整的包可能会被TCP拆成多个包进行发送，也有可能把多个小包封装成一个大的数据包发送，这就是TCP的粘包和拆包问题。数据从发送方到接收方需要经过操作系统的缓冲区，粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起。抓包是发送的数据大于缓冲区进行拆分处理。

### 粘包和拆包的解决办法

​		由于底层的TCP无法理解上层的业务数据，所以在底层无法保证数据包不被拆分或重组，这个问题只能通过上层的协议栈设计来解决，主流的协议解决办法如下：

* 消息长度固定，累计读取到长度或定长的报文后，就认为读取到了一个完整的信息。
* 将回车换行符作为消息结符。
* 将特殊的分隔符作为消息的结束标识。
* 通过在消息中定义长度字段来标识消息的总长度。



### Netty的粘包和拆包

* 固定长度的拆包器FixedLengthFrameDecoder每个应用层数据包的拆分都是固定长度。
* 行拆包器LineBasedFrameDecoder每个应用层数据包都以换行符作为分隔符进行拆分。
* 分隔符拆包顺DelimiterBasedFrameDecoder每个应用层数据包都通过自定义的分隔符进行拆分。
* 基于数据长度的拆包器LengthFieldBasedFrameDecoder将应用层数据包的长度作为接收端数据包的拆分依据，按照应用层数据包的大大小拆包。